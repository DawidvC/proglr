structure Resource = struct
  val resources = [
  ("smlnj-lib/PORTING", "Here is a brief description of the changes since the 0.3beta release of\nthe SML/NJ library in 1994.  Modules are listed in alphabetical order.\n\n--------------------------------------------------------------------\nSummary\n-------\n    - eliminate weak types in signatures.\n\n    - name changes to track SML Basis conventions.\n\t- change names, argument order of iteration combinators\n\t- use MONO_XXX/XXX instead of XXX/POLY_XXX for signatures.\n\n    - consolidate signatures\n\t- e.g., use ORD_MAP for the Int*Map structures.\n\n    - Name structure is renamed Atom.\n\t- removed name_tbl type and operations and define free-standing\n\t  structures AtomBinaryMap, AtomBinarySet and AtomTable.\n\n    - split Format structure into Format and Scan\n\n    - moved Unix specific modules to Unix library (use unix-lib.cm\n      in sources file to access).\n\n    - remove signatures and structures that are redundant with the\n      SML Basis Library.\n\n--------------------------------------------------------------------\nDetailed Changes\n----------------\n\nfunctor ArrayQSort (...) : ARRAY_SORT\n\t==>\tArrayQSortFn (...) : MONO_ARRAY_SORT\n\nstructure BigInt : BIGINT\n\t==>\tIntInf : INT_INF\n\tThe IntInf structure mostly matches that defined by SML'97.\n\nfunctor BinaryDict(...) : DICT\n\t==>\tBinaryMapFn(...) : ORD_MAP\n\nfunctor BinarySet(...)\n\t==>\tBinarySetFn(...)\n\nstructure CType : CTYPE\n\tDeleted.  Use operations from Char structure in basis.\n\nsignature DICT\n\t==>\tORD_MAP\n\tAlso, various function names changed to track the SML'97 naming\n\tconventions:\n\t\tval find : ...\n\t\t\tDeleted.\n\t\tval peek : ...\n\t\t\t==> find : ...\n\t\tval listItems : ...\n\t\t\t==> listItemsi : ...\n\t\tval app : ...\n\t\t\t==> appi : ...\n\t\tval revapp : ...\n\t\t\tDeleted.\n\t\tval map : ...\n\t\t\t==> mapi : ...\n\t\tval fold : ...\n\t\t\t==> foldr\n\t\tval revfold : ...\n\t\t\t==> foldl\n\t\tval transform : ...\n\t\t\t==> map : ...\n\tAlso, the ORD_MAP interface provides the following new operations:\n\tinsert', listItems, collate, unionWith, unionWithi, intersectWith,\n\tintersectWithi, app, foldl, foldr, filter, filteri, mapPartial,\n\tand mapPartiali.\n\nstructure Finalizer : FINALIZER\n\tDeleted.  No replacement as of yet.\n\nstructure Format : FORMAT\n\tThe scanning functions were moved to a new module (Scan : SCAN).\n\tAlso, the fmt_item datatype has changed.\n\nfunctor HashTable (...) : HASH_TABLE\n\t==>\tHashTableFn (...) : MONO_HASH_TABLE\n\nstructure IntMap : INTMAP\n\t==>\tIntBinaryMap : ORD_MAP\n\talso\tIntListMap : ORD_MAP\n\nstructure IntSet : INTSET\n\t==>\tIntBinarySet : ORD_MAP\n\talso\tIntListSet : ORD_MAP\n\nstructure LibBase\n\tUses of the LibBase.BadArg exception have been replaced by\n\tthe Fail exception from the SML'97 basis.  The function\n\tLibBase.failure replaces LibBase.badArg.\n\tUses of the type LibBase.relation have been replaced by the\n\torder type from the SML'97 basis.\n\tThe type of the version value has changed, and the value\n\tversionName is now called banner.\n\nstructure ListUtil : LIST_UTIL\n\tDeleted.  Use the operations from List and ListPair in the\n\tSML'97 basis.\n\nstructure Name : NAME\n\t==>\tAtom : ATOM\n\tand\tAtomTable : ATOM_TABLE\n\nstructure MakeString : MAKESTRING\n\tDeleted.  In SML'97, basic types provide their own conversion\n\tfunctions.\n\nsignature ORD_SET\n\tMany function names changed to track the SML'97 naming conventions:\n\t\tval find : ...\n\t\t\tDeleted\n\t\tval peek : ...\n\t\t\t==> find : ...\n\t\tval fold : ...\n\t\t\t==> foldr : ...\n\t\tval revfold : ...\n\t\t\t==> foldl : ...\n\tAlso, the ORD_SET interface provides the following new operations:\n\tadd', compare, and filter.\n\nstructure PolyHashTable : POLY_HASH_TABLE\n\t==>\tHashTable : HASH_TABLE\n\nstructure PolyArrayQSort : POLY_ARRAY_SORT\n\t==>\tArrayQSort : ARRAY_SORT\n\nstructure Rand : RAND\n\t==>\tRandom : RANDOM\n\nstructure Random : RANDOM\n\t==>\tRand : RAND\n\nfunctor SplayDict (...) : DICT\n\t==>\tSplayMapFn (...) : ORD_MAP\n\nfunctor SplaySet (...)\n\t==>\tSplaySetFn (...)\n\nstructure StringUtil : STRING_UTIL\n\tDeleted.  Use operations from String and Substring structures.\n\nstructure StringCvt : STRING_CVT\n\tDeleted.  In SML'97, basic types provide their own conversion\n\tfunctions.\n\nstructure UnixPath : UNIX_PATH\n\t==> structure PathUtil : PATH_UTIL\n\tMany of the operations defined in the UnixPath structure are\n\tnow part of the OS.FileSys and OS.Path structures in the SML'97\n\tbasis.  The remaining operations are findFile and findFiles.\n\tIn addition, two new functions are provided: existsFile and\n\tallFiles.\n\n--------------------------------------------------------------------\nNew modules\n-----------\nKeywordFn\nHash2TableFn\nstructure ParserComb : PARSER_COMB\nstructure SimpleURef : UREF\nstructure URef : UREF\n\n--------------------------------------------------------------------\nNew Libraries\n-------------\nHTML library\nReactive library\nRegular expression library\n"),
  ("smlnj-lib/Util/utf8-sig.sml", "(* utf8-sig.sml\n *\n * COPYRIGHT (c) 2007 John Reppy (http://www.cs.uchicago.edu/~jhr)\n * All rights reserved.\n *\n * Routines for working with UTF8 encoded strings.\n *)\n\nsignature UTF8 =\n  sig\n\n    type wchar = word\n\n    val maxCodePoint : wchar\t(* = 0wx0010FFFF *)\n\n    exception Incomplete\n\t(* raised by some operations when applied to incomplete strings. *)\n\n    val getu : (char, 'strm) StringCvt.reader -> (wchar, 'strm) StringCvt.reader\n\t(* convert a character reader to a wide-character reader *)\n\n    val explode : string -> wchar list\n\t(* return the list of wide characters that are encoded by a string *)\n    val fold : ((wchar * 'a) -> 'a) -> 'a -> string -> 'a\n\t(* fold a function over the Unicode characters in the string *)\n    val size : string -> int\n\t(* return the number of Unicode characters *)\n\n    val encode : wchar -> string\n\t(* return the UTF8 encoding of a wide character *)\n\n    val isAscii : wchar -> bool\n    val toAscii : wchar -> char\t\t(* truncates to 7-bits *)\n    val fromAscii : char -> wchar\t(* truncates to 7-bits *)\n\n    val toString : wchar -> string\n\t(* return a printable string representation of a wide character *)\n\n  end\n\n"),
  ("smlnj-lib/Util/utf8.mlb", "$(SML_LIB)/basis/basis.mlb\nutf8-sig.sml\nutf8.sml\n"),
  ("smlnj-lib/Util/utf8.sml", "(* utf8.sml\n *\n * COPYRIGHT (c) 2007 John Reppy (http://www.cs.uchicago.edu/~jhr)\n * All rights reserved.\n *\n * Routines for working with UTF8 encoded strings.\n *\n *\tUnicode value\t\t1st byte    2nd byte    3rd byte    4th byte\n *\t-----------------\t--------    --------    --------    --------\n *\t00000000 0xxxxxxx\t0xxxxxxx\t\n *\t00000yyy yyxxxxxx\t110yyyyy    10xxxxxx\n *\tzzzzyyyy yyxxxxxx\t1110zzzz    10yyyyyy\t10xxxxxx\n *\t110110ww wwzzzzyy+\n *\t110111yy yyxxxxxx\t11110uuu    10uuzzzz\t10yyyyyy    10xxxxxx!\n *\n * (!) where uuuuu = wwww+1\n *\n * TODO:\n *    Add support for surrogate pairs.\n *)\n\nstructure UTF8 :> UTF8 =\n  struct\n\n    structure W = Word\n    structure SS = Substring\n\n    type wchar = W.word\n\n    val maxCodePoint : wchar = 0wx0010FFFF\n\n    exception Incomplete\n\t(* raised by some operations when applied to incomplete strings. *)\n\n    fun getContByte getc (wc, ss) = (case (getc ss)\n\t   of NONE => raise Incomplete\n\t    | SOME(c, ss') => let\n\t\tval b = W.fromInt(Char.ord c)\n\t\tin\n\t\t  if (W.andb(0wxc0, b) = 0wx80)\n\t\t    then (W.orb(W.<<(wc, 0w6), W.andb(0wx3f, b)), ss')\n\t\t    else raise Incomplete\n\t\tend\n\t  (* end case *))\n\n  (* convert a character reader to a wide-character reader *)\n    fun getu getc = let\n\t  val getContByte = getContByte getc\n\t  fun get strm = (case getc strm\n\t\t of NONE => NONE\n\t\t  | SOME(c, strm) => let\n\t\t      val w = W.fromInt(Char.ord c)\n\t\t      in\n\t\t\tif (w < 0w128)\n\t\t\t  then SOME(w, strm)\n\t\t\telse (case (W.andb(0wxe0, w))\n\t\t\t   of 0wxc0 => SOME(getContByte (W.andb(0wx1f, w), strm))\n\t\t\t    | 0wxe0 => SOME(getContByte(getContByte(W.andb(0wx0f, w), strm)))\n\t\t\t    | _ => raise Incomplete\n\t\t\t  (* end case *))\n\t\t      end\n\t\t(* end case *))\n\t  in\n\t    get\n\t  end\n\n  (* fold a function over the Unicode characters in the string *)\n    fun fold f = let\n\t  val getContByte = getContByte SS.getc\n\t  fun foldf (ss, acc) = (case SS.getc ss\n\t\t of NONE => acc\n\t\t  | SOME(c, ss) => let\n\t\t      val w = W.fromInt(Char.ord c)\n\t\t      in\n\t\t\tif (w < 0w128)\n\t\t\t  then foldf (ss, f(w, acc))\n\t\t\telse (case (W.andb(0wxe0, w))\n\t\t\t   of 0wxc0 => let\n\t\t\t\tval (wc, ss) = getContByte(W.andb(0wx1f, w), ss)\n\t\t\t\tin\n\t\t\t\t  foldf (ss, f(wc, acc))\n\t\t\t\tend\n\t\t\t    | 0wxe0 => let\n\t\t\t\tval (wc, ss) =\n\t\t\t\t      getContByte(\n\t\t\t\t\tgetContByte(W.andb(0wx0f, w), ss))\n\t\t\t\tin\n\t\t\t\t  foldf (ss, f(wc, acc))\n\t\t\t\tend\n\t\t\t    | _ => raise Incomplete\n\t\t\t  (* end case *))\n\t\t      end\n\t\t(* end case *))\n\t  in\n\t    fn init => fn s => foldf (SS.full s, init)\n\t  end\n\n  (* return the list of wide characters that are encoded by a string *)\n    fun explode s = rev(fold (op ::) [] s)\n\n  (* return the number of Unicode characters *)\n    fun size s = fold (fn (_, n) => n+1) 0 s\n\n    fun w2c w = Char.chr(W.toInt w)\n\n  (* return the UTF8 encoding of a wide character *)\n    fun encode wc = if (W.<(wc, 0wx80))\n\t    then String.str(w2c wc)\n\t  else if (W.<(wc, 0wx800))\n\t    then String.implode[\n\t\tw2c(W.orb(0wxc0, W.>>(wc, 0w6))),\n\t\tw2c(W.orb(0wx80, W.andb(wc, 0wx3f)))\n\t      ]\n\t    else String.implode[\n\t\tw2c(W.orb(0wxe0, W.>>(wc, 0w12))),\n\t\tw2c(W.orb(0wx80, W.andb(W.>>(wc, 0w6), 0wx3f))),\n\t\tw2c(W.orb(0wx80, W.andb(wc, 0wx3f)))\n\t      ]\n\n    fun isAscii (wc : wchar) = (wc < 0wx80)\n    fun toAscii (wc : wchar) = w2c(W.andb(0wx7f, wc))\n    fun fromAscii c = W.andb(0wx7f, W.fromInt(Char.ord c))\n\n  (* return a printable string representation of a wide character *)\n    fun toString wc =\n\t  if isAscii wc\n\t    then Char.toCString(toAscii wc)\n\t    else \"\\\\u\" ^ (StringCvt.padLeft #\"0\" 4 (W.toString wc))\n\n  end\n\n"),
  ("smlnj-lib/Util/utf8-sig.smi", "_require \"basis.smi\"\n"),
  ("smlnj-lib/Util/utf8.smi", "_require \"basis.smi\"\n_require \"utf8-sig.sml\"\n\nstructure UTF8 = struct\n\n    type wchar = word\n\n    val maxCodePoint : wchar\t(* = 0wx0010FFFF *)\n\n    exception Incomplete\n\t(* raised by some operations when applied to incomplete strings. *)\n\n    val getu : (char, 'strm) StringCvt.reader -> (wchar, 'strm) StringCvt.reader\n\t(* convert a character reader to a wide-character reader *)\n\n    val explode : string -> wchar list\n\t(* return the list of wide characters that are encoded by a string *)\n    val fold : ((wchar * 'a) -> 'a) -> 'a -> string -> 'a\n\t(* fold a function over the Unicode characters in the string *)\n    val size : string -> int\n\t(* return the number of Unicode characters *)\n\n    val encode : wchar -> string\n\t(* return the UTF8 encoding of a wide character *)\n\n    val isAscii : wchar -> bool\n    val toAscii : wchar -> char\t\t(* truncates to 7-bits *)\n    val fromAscii : char -> wchar\t(* truncates to 7-bits *)\n\n    val toString : wchar -> string\n\t(* return a printable string representation of a wide character *)\n\nend\n"),
  ("smlnj-lib/Util/README", "This is the utility library of the SML/NJ Library.  The services provided\ncan be grouped as follows:\n\n  - Data structures\n    - Hash tables\n    - Finite maps of ordered keys\n    - Finite sets of ordered elements\n    - Queues\n    - Arrays\n\n  - Searching and sorting\n\n  - String conversions\n\n  - Some miscellaneous utility modules. \n"),
  ("smlnj-lib/Util/TODO", "Improve implementation of unionWith/intersectWith in BinaryMapFn, IntBinaryMap,\nand SplayMapFn.\n\nNew iterator module\n\n"),
  ("smlnj-lib/LICENSE", "STANDARD ML OF NEW JERSEY COPYRIGHT NOTICE, LICENSE AND DISCLAIMER.\n\nCopyright (c) 1989-2002 by Lucent Technologies\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth the copyright notice and this permission notice and warranty\ndisclaimer appear in supporting documentation, and that the name of\nLucent Technologies, Bell Labs or any Lucent entity not be used in\nadvertising or publicity pertaining to distribution of the software\nwithout specific, written prior permission.\n\nLucent disclaims all warranties with regard to this software,\nincluding all implied warranties of merchantability and fitness. In no\nevent shall Lucent be liable for any special, indirect or\nconsequential damages or any damages whatsoever resulting from loss of\nuse, data or profits, whether in an action of contract, negligence or\nother tortious action, arising out of or in connection with the use\nor performance of this software.\n"),
  ("smlnj-lib/README", "This is the SML/NJ Library.  It is free software distributed under the SML/NJ\nsystem's license (see the LICENSE file for details).\n\nThe library is organized as a collection of CM libraries. Here is a roadmap of\nthe library structure:\n\n  Directory\tSources File\t\tDescription\n  -------------------------------------------------\n  Util\t\tsmlnj-lib.cm\t\tThis is the general utility library.\n\n  Controls\tcontrols-lib.cm\t\tThis is a library of support code\n\t\t\t\t\tfor managing application controls.\n\n  HashCons\thash-cons-lib.cm\tThis is a library supporting hash-consing\n\t\t\t\t\tof data structures and efficient sets and\n\t\t\t\t\tmaps using hash-consed keys.\n\n  HTML\t\thtml-lib.cm\t\tThis library provides parsing and pretty\n\t\t\t\t\tprinting of HTML (Version 3.2).\n\n  INet\t\tinet-lib.cm\t\tNetworking utilities (for both Unix\n\t\t\t\t\tand Windows).\n\n  PP\t\tpp-lib.cm\t\tPretty-printing library.\n\n  Reactive\treactive-lib.cm\t\tA low-level reactive scripting library.\n\n  RegExp\tregexp-lib.cm\t\tRegular-expression library.\n\n  Unix\t\tunix-lib.cm\t\tUnix specific utilities.\n\nThe first column is the source directory, the second gives the library sources\nfile alias (to be used in your application's sources.cm file), and the third\ncolumn gives a brief description.  Look at the Doc dicrectory and at the README\nfiles in the individual subdirectories for more documentation.\n\n"),
  ("smlnj-lib/CHANGES", "This is a list of changes to the SML/NJ Library; the version numbers\ncorrespond to SML/NJ releases.\n\n--------------------------------------------------------------------------------\nSML/NJ 110.76\n-------------------\n\n[2012-10-30]\n\tFixed bug in DynamicArray iterators because of bad slice dimensions\n\t(bug #108).  Also switched to using Array.fromList to implement fromList\n\tfunction.\n\n--------------------------------------------------------------------------------\nSML/NJ 110.75\n-------------------\n\n[2012-09-24]\n\tAdded Base64 module to support encoding and decoding Word8 vectors as\n\tbase64 strings.\n\n[2012-09-23]\n\tAdded exists, existsi, all, and alli functions to ORD_MAP signature and\n\timplementations.\n\n[2012-09-23]\n\tAdded all function to ORD_SET signature and implementations.\n\n[2012-03-26]\n\tAdded subtract, subtract', and subtractList functions to ORD_SET\n\tinterface and implementations.\n\n[2012-03-09]\n\tModified PathUtil module to handle the case where the filename is an\n\tabsolute path.\n\n--------------------------------------------------------------------------------\nSML/NJ 110.74\n-------------------\n\n[2011-11-25]\n\tAdded hash-table-based implementation of sets (HASH_SET signature and\n\tHashSetFn functor).\n\n[2011-05-23]\n\tAdded new S-expression library (contributed by Damon Wang)\n\n[2011-05-17]\n\tFixed bug in JSON scanner.  It didn't handle escaped backslash or double\n\tquote correctly.\n\n--------------------------------------------------------------------------------\nSML/NJ 110.73\n-------------------\n\n[2011-05-12]\n\tModified the implementation of GetOpt.usageInfo so that if the help\n\tstring has embedded newlines, then the extra lines are properly\n\tindented.\n\n[2011-04-10]\n\tChanged the interface of JSONStreamParser to support both parsing files\n\tand TextIO.instreams.\n\n[2011-03-16]\n\tAdded findExe function to PathUtil module.\n\n[2010-06-30]\n\tAdded HTML4 library.\n\n[2010-03-09]\n\tFixed bug in hashed cons library (bug #55).\n\n--------------------------------------------------------------------------------\nSML/NJ 110.72\n-------------------\n\n[2009-05-13]\n\tAdded array iterators to DynamicArray module.\n\n[2009-03-15]\n\tAdded support for the interval syntax to the AWK RE syntax parser (this\n\tsyntax was not part of the original version of AWK, but is supported by\n\tmodern variants and the POSIX standard).\n\n[2008-10-03]\n\tImproved the error messages in the JSON parser.\n\n[2008-06-11]\n\tAdded support for begin marks to Thompson engine.\n\n[2008-05-12]\n\tAdded parsing support to JSON library.\n\n[2008-04-18]\n\tFirst commit of JSON Library.  Printing works, but parsing still needs\n\tto be implemented.\n\n[2008-03-18]\n\tCommitted a major overhaul of the RegExp library.  There is now a new\n\tengine that implements Ken Thompson's RE matching algorithm.  The result\n\ttype of the RE matches has also been simplified by removing an unecessary\n        option type.\n\tNOTE: the new RE engine is not complete in that it does not yet support\n\tbegin/end marks.\n\n[2007-12-13]\n\tAlso added list' and listg' which are parameterized over the delimiter-\n\tand separator strings used for formatting lists.  (The default for \"list\" and\n\t\"listg\" is the usual \"[\" \", \" \"]\".)\n\n[2007-12-13]\n\tAdded \"elem\" function as an inverse to \"glue\" to FormatComb module.\n\tThis makes writing extensions possible.  Also added \"list\" and \"option\"\n\tcombinators for formatting list- and option types.\n\n[2007-11-02]\n\tA collection of bug fixes for machine.sml in the Reactive library.\n\t(Thanks to Timothy Bourke)\n\n[2007-05-15]\n\tMade the UnixPath.path_list type concrete (= string list).\n\n[2007-04-24]\n\tAdded next function to Fifo and Queue modules.\n\n[2007-02-15]\n\tRemoved vestigial IntInf and INT_INF definitions.\n\n[2007-02-14]\n\tChanged the representation type of UTF8.wchar from Word32.word to word.\n\tAlso added the UTF8.maxCodePoint value.\n\n[2007-01-30]\n\tAdded the lookup function to the ORD_MAP interface.\n\n[2007-01-30]\n\tAdded the fromList function to the ORD_SET interface.  For the red-black\n\ttree and list based implementations, this operation is linear for ordered\n\tinputs.\n\n[2007-01-28]\n\tAdded UTF8 signature and structure.\n\n[2005-11-07]\n\tInternal change: replaced uses of the depreciated Substring.all\n\twith the Substring.full\n\n[2005-11-05]\n\tTweaking of the interval set API.  Added iterators on items and\n\tchanged the iterators on intervals to have a \"Int\" suffix.\n\tChanged addInterval to addInt, changed list to intervals.  Added\n\tthe items function.\n\n[2005-10-31]\n\tFixed a bug in IntervalSetFn().intersect.\n\n[2005-10-25]\n\tAdded interval sets to utility library (signatures INTERVAL_DOMAIN\n\tand INTERVAL_SET, and functor IntervalSetFn).\n\n[2005-08-04]\n\tRenamed graph-scc.sml to graph-scc-fn.sml.\n\n[2005-07-23]\n\tFix PP library to export ANSITermDev, ANSITermPP, PPDescFn, and\n\tPP_DESC.  Also add nbSpace to PP_DESC signature.\n\n[2005-07-12]\n\tAdded ANSITermDev device that uses ANSI terminal display attributes\n\tand added a ANSITermPP for pretty printing to such a device.\n\n[2005-07-06]\n\tAdded ANSITerm structure, which provides support for ANSI terminal\n\tdisplay attributes (e.g., red text).\n\n[2005-07-06]\n\tRefactored the pretty printing library.  The declarative way to\n\tconstruct pretty-printing descriptions now sits on top of the\n\tPP_STREAM interface.  Also removed \"onNewline\" function, which\n\twas not implemented.\n\n[2005-05-05]\n\tAdded singleton function to MONO_PRIORITYQ interface.\n\n[2005-05-04]\n\tAdded the \"join\" combinator to ParserComb.\n\n[2005-03-21]\n\tFixed a bug in GetOpt.getOpt.  The argument processing functions\n\tfor ReqArg and OptArg, and the embedding function for ReturnInOrder\n\twere getting applied to all arguments, even past a \"--\".\n\n[2005-02-11]\n\tAdded Atom.same and Atom.lexCompare to the Atom structure.  Eventually,\n\tAtom.sameAtom will be removed.\n\n[2004-12-15]\n\tChange HashString.hashString' to hashSubstring.\n\n[2004-12-09]\n\tAdded two simple statistics modules:\n\t* RealOrderStats implements selection of arbitrary order\n          statistics as well as the median of an array of reals\n\t  in randomized linear time.\n\t* UnivariateStats implements mean, variance, standard and average\n\t  deviation, skew, kurtosis, and median of a univariate sample\n\t  (i.e., a set of reals).\n\n[2004-11-29]\n\tAdded HashString.hashString' for substrings.\n\tHand-inlined CharVector.fold into HashString for efficiency.\n\tModified atom.sml so that Atom.atom' first tries to find an\n\texisting atom before turning its argument into a string. [-blume]\n\n[2003-09-03]\n\tMinor modifications to random.sml due to changes to some\n\tBasis interfaces (slices).\n\tSignificant surgery on bit-array.sml to make it compile with\n\tnew signature MONO_ARRAY.  This will require further cleanup\n\tin the future.\n\n[2003-08-28]\n\tMade compilation of int-inf* conditional.  (The Basis now has\n\ta spec-conforming implementation of IntInf, so the one here is\n\tno longer needed.)  [-blume]\n\n[2003-07-31]\n\tAdded getDevice function to PP_STREAM signature.\n\n[2003-05-27]\n\tAvoid poly-eq in Util/parser-comb.sml.\n\n[2003-05-22]\n\tMore cleanup (all in the name of eliminating incomplete matches):\n\t  - in HTML/html-attrs-fn.sml: fill in missing patterns in two\n\t    case expressions\n\t  - in HTML/html-gram: rewrote function groupDefListContents\n\t    to avoid the (unnecessary) incomplete match\n\t  - in PP/devices/html-dev.sml: made the implementation of popStyle\n\t    agree with the comment above it (popStyle on an empty\n\t    stack is supposed to be a nop)\n\t  - in PP/src/pp-stream-fn.sml: function setSize: handle case of\n\t    an empty scanStk\n\t  - in Util/prime-sizes.sml: raise Fail exceptions instead of\n\t    Match exceptions when reaching the end of a list\n\t    (Perhaps this should eventually be rewritten using an on-demand\n\t     prime-number generator that kicks when needed.)\n\n[2003-05-22]\n\tCleanup logic in Scan.scanf function.\n\n[2002-10-03]\n\tFixed bug in formating reals with the %g format.\n\n[2002-06-18]\n\tFixed a bug in MatchTree.nth (regexp library).  Thanks to\n\tSami Nopanen.\n\n[2002-05-20]\n\tFixed bug in IntInf module: scanning of hex literals was not\n\thandling \"0x\" prefixes.\n\n[2002-05-20]\n\tAdded ControlUtil module and stringControls function.\n\n[2002-05-17]\n\tAdded tyName field to ValueSyntax exception in Controls module\n\tand path field to registry tree in ControlRegistry module.\n\n[2002-05-17]\n\tAdded == and != operators to INT_INF interface.  These are a\n\tplaceholder until IntInf moves into the SML/NJ compiler.\n\n[2002-05-16]\n\tAdded mergeWith function to ORD_MAP interface.\n\n[2002-05-15]\n\tRevised Controls library.\n\n[2002-04-17]\n\tAdded Matthias Blume's implementation of Danvey-style format\n\tcombinators to the Util library.\n\n[2002-03-14]\n\tMerged in Matthias Blume's Controls library.  Warning: the API\n\tto this library is likely to change as we get some experience\n\twith it.\n\n[2002-03-11]\n\tAdded consR1 .. consR5 functions to HashCons library.  These\n\tcan be used to hash-cons record types.\n\n[2002-02-21]\n\tFixed infinite loop in LeftPriorityQFn.fromList when given a\n\tsingleton list as input (Chris Okasaki provided the fix).\n\n[2002-02-12]\n\tAdded implementation of priority queues to Util library (using\n\tOkasaki's leftist-tree implementation).\n\n[2001-10-19]\n\tAdded new HashCons library.\n\n[2001-10-19]\n\tAdded PrimeSizes module to Util library.\n\n[2001-09-27]\n\tFixed bug in UnixEnv module (reported by Leunga).\n\n[2001-05-05]\n\tAdded addrToString function to SockUtil module in INet library.\n\n[2001-05-04]\n\tModified GraphSCC module to support a list of roots (Blume).\n\tThe old interface still works, but will be dropped when we move\n\tto the new Util library.\n\n[2001-04-06]\n\tAdded partition function to ORD_SET interface.\n\n[2001-04-05]\n\tAdded hasProps function to PropList module.\n\n[2001-03-16]\n\tMinor bug fix in GetOpt: don't pad the help string, since it causes\n\tline wraps when one of the help lines is longer than the screen\n\twidth.  It was also unneccesary.\n\n[2001-02-23]\n\tAdded inDomain function to the various kinds of hash tables.\n\n[2001-02-22]\n\tFixed bug in {Int,Word}RedBlackMapFn.insert (bug 1591).\n\n[2000-12-13]\n\tAdded the bit operations to the IntInf module (Leung).\n\n[2000-11-17]\n\tAdded where clause to GraphSCCFn result signature (Blume).\n\n[2000-10-20]\n\tMade the result signature of the RegExpFn functor be opaque.\n\n[2000-09-28]\n\tSML/NJ 110.0.7 release.\n\n[2000-09-02]\n\tAdded Word versions of hash tables (WordHashTable), finite\n\tmaps (WordRedBlackMap), and sets (WordRedBlackSet).\n\n[2000-09-02]\n\tfixed bug in Format module (infinity caused infinite loop).\n\n[2000-07-19]\n\tadded anchored paths in CM files for NEW_CM.\n\n[2000-06-30]\n\tadded implementation of LWORD in Format module.\n\n[2000-05-16]\n\tFixed bug in dfa-engine.sml (bug number 1559).\n\n[2000-05-08]\n\tAdded setFn to PList.newProp return type.\n\n[2000-05-05]\n\tAdded sameHolder function to PropList module.\n\n[2000-04-05]\n\tFixed a bug in the filter/filteri hash table functions: the number\n\tof items in the table was not being recomputed.\n\n[2000-04-04]\n\tAdded modify and modifyi iterators to hash tables.\n\n[2000-03-28]\n\tAdded anchorLink style to HTMLDev structure in PP/devices.\n\n[1999-12-03]\n\tAdded IntHashTable structure to Util library; this structure is\n\ta specialization of hash tables to integer keys.\n\n[1999-12-03]\n\tAdded default cases to avoid \"match not exhaustive\" warnings.\n\n[1999-12-03]\n\tAdded GraphSCCFn functor to Util library, which implements a\n\tstrongly-connected components algorithm on directed graphs (written\n\tby Matthias Blume).\n\n[1999-11-10]\n\tFixed a benign type error in RegExp/BackEnd/fsm.sml that was exposed by\n\tthe previous change.\n\n[1999-11-7]\n\tMade the result signatures of ListSetFn and ListMapFn opaque.\n\n[1999-11-1]\n\tFixed bug in PP/devices/sources.cm under new CM (missing smlnj-lib.cm).\n\n[1999-10-20]\n\tFixed bug in RedBlack trees (the linear time construction of\n\ttrees from ordered sequences was producing backwards trees).\n\n[1999-10-18]\n\tChanged UREF signature so that union, unify, and link operations\n\tnow return a boolean.\n\n[1999-10-18]\n\tAdded peekFn to PropList.newProp return result.\n\n[1999-10-14]\n\tAdded TextIOPP structure to pp-lib.cm (it was not being exported).\n\n[1999-09-21]\n\tChanged the getOpt API.  Errors are now reported using a callback\n\tand both usage and getOpt take records as arguments.  Also changed\n\tthe NoArg descriptor to take a function so that imperative argument\n\tprocessing can be supported.\n\n[1999-09-20]\n\tChanged CM files to be compatible with both the old (110.0.x) and\n\tnew (110.20+) versions of CM.\n\n[1999-09-17]\n\tAdded PropList:PROP_LIST structure.  This structure implements\n\tproperty lists using Stephen Weeks's technique.\n\n[1999-09-17]\n\tImproved the red-black tree implementations with linear-time union,\n\tintersection, difference, and filter operations.  Also reimplemented\n\tthe delete function in a way that does not require an extra constructor.\n\n[1999-09-09]\n\tAdded Red-Black-Tree implementation of sets and maps.  Two new\n\tfunctors (RedBlackMapFn and RedBlackSetFn) and four new structures\n\t(IntRedBlackMap, IntRedBlackSet, AtomIntRedBlackMap, and IntRedBlackSet).\n\tAlso added aliases AtomMap and AtomSet that for the RB implementations.\n\n[1999-09-03]\n\tAdded missing support for WORD and WORD8 format items to Format structure.\n\tStill need to handle LWORD items!!\n\n[1999-08-17]\n\tAdded DynamicArray:DYNAMIC_ARRAY structure.\n\n[1999-07-06]\n\tAdded declarative representation of pretty-printing to PPStreamFn.\n\tThis replaces the PPDescFn and PP_DESC components (which were not\n\timplemented anyway).\n\n[1999-07-02]\n\tMoved SockUtil structure into a new INet library.  Also split out the\n\tUnix-specific socket operations into a UnixSockUtil module.  (Sockets\n\tare now supported on Win32).\n\n[1999-06-17]\n\tAdded listKeys function to ORD_MAP API.\n\n[1999-06-14]\n\tAdded Riccardo Pucella's GetOpt structure to Util library.\n\n[1999-06-14]\n\tAdded singleton and inDomain functions to ORD_MAP API.\n\n[1999-06-02]\n\tMerged in some bug fixes from the compiler's version of the IntInf\n\tstructure.\n\n[1999-05-05]\n\tFixed a couple of bugs in the PP library having to do with nesting\n\tabsolute and relative indentations.\n\n[1999-04-21]\n\tAdded a way to pass control information to a PP device via the PP\n\tstream (function control in PP_STREAM).\n\n[1999-04-16]\n\tAdded better style support to the HTML PP device.\n\n[1998-09-04]\n\tAdded isEmpty predicate and first fucntion to ORD_MAP\n\tsignature (and to implementations).\n\n[1998-06-23]\n\tFixed a bug in ParserComb.bind (reported by Andrew Kennedy).\n\n--------------------------------------------------------------------------------\n[1998-04-15] 110 --> 110.5\n--------------------------\n\nThere is now a regular expression library (mostly implemented by Riccardo\nPucella).  The implementation separates front-ends (which specify the\nsyntax of REs) from back-ends (which implement the matching algorithms).\nCurrently, we support AWK syntax as the only front-end and two different\nback-ends.\n\nAdded an implementation of the SML/NJ PP API to the pretty-printer examples.\n\nFixed a bug in the IntInf structure with scanning strings of the form \"1+2\".\nAlso did some clean-up of the code.\n\n\n--------------------------------------------------------------------------------\n[1997-12-07] 109.32 --> 110\n---------------------------\n\nAdded the function add' to the ORD_SET signature and the function insert'\nto the ORD_MAP signature.  These functions fit the pattern of the fold\nfunctions. (110 patch 3)\n\nAdded the IntInf:INT_INF structure to the Util library.  This is a subset\nof the optional IntInf structure defined by the SML'97 basis.\n\nChanged the Rand structure to use words as seeds and results.  This also\nfixes bug 1047. (110 patch 3)\n\nAdded a clear operation to the Queue and various hash table structures.\n\nChanged the ListFormat.formatList to ListFormat.fmt and ListFormat.scanList\nto ListFormat.scan.  Added the function ListFormat.listToString.\n\nUpdated the HTML library to the final 3.2 specification.  This involved adding\na new BODY element type (with attributes).  Also, removed the header/footer\narguments to the pretty-printer (they were a gross hack).\n\nAdded PathUtil structure to Util library.  This is a more general version\nof the old UnixPath module.\n\n\n--------------------------------------------------------------------------------\n[1997-10-01] 109.31 --> 109.32\n------------------------------\n\nChanged the type of the exec instruction in the Reactive library.\n\n\n--------------------------------------------------------------------------------\n[1997-09-09] 109.30 --> 109.31\n------------------------------\n\nAdded the Reactive library, which supports reactive scripting.  This is a\nfirst cut, and hasn't been extensively tested.\n\nChanged the names of SockUtil.sock{Recv,Send}* to SockUtil.{recv,send}*\n(since the sock prefix was redundant).\n\nAdded some bug fixes to IntListSet that had previously been added to\nthe ListSetFn implementation.\n\n\n--------------------------------------------------------------------------------\n[1997-07-17] 109.29 --> 109.30\n------------------------------\n\nAdded a missing case to {ListSetFn,IntListSet}.isSubset.\n\nThe bug fix for unionWith was broken.  I think I've got it right this\ntime.\n\n\n--------------------------------------------------------------------------------\n[1997-07-17] 109.29 --> 109.30\n------------------------------\n\nFixed a bug in the binary-tree and splay-tree implementations of the\nunionWith[i] and intersectWith[i] functions.  The bug caused the order\nof arguments to the merging function to be wrong in some cases.\n\nFixed uses of System.Unsafe.\n\nRemoved Array2:ARRAY2 from Util library, since the basis now defines these.\n\nAdded MonoArrayFn functor for easy creation of monomorphic array structures.\n\nAdded Atom.atom' operation for turning substrings into atoms.\n\n\n--------------------------------------------------------------------------------\n[1997-06-13] 109.28 --> 109.29\n------------------------------\n\nAdded collate operation to ORD_MAP signature.\n\nAdded compare operation to ORD_SET signature.\n\nChanged the type of and intersectWith[i] in the ORD_MAP signature to be\nmore general.\n\nChanged the type of the map function in the ORD_SET signature to return\na new set (instead of a list).\n\n\n--------------------------------------------------------------------------------\n[1997-05-22] 109.27 --> 109.28\n------------------------------\n\nChanged various sharing constraints to \"where type\" definitions to\ncompile in SML'97.\n\nAdded AtomBinaryMap and AtomBinarySet structures to Util library.\n\n\n--------------------------------------------------------------------------------\n[1997-03-03] 109.25.1 --> 109.25.2\n----------------------------------\n\nChanged Util/time-limit.sml to reflect new location of callcc/throw.\n\n\n--------------------------------------------------------------------------------\n[1997-02-25] 109.25 --> 109.25.1\n--------------------------------\n\nAdded a bunch of new operations to the ordered map modules (BinaryMapFn,\nIntBinaryMap, ListMapFn, IntListFn, and SplayMapFn).  The new operations\nare:\n    val unionWith  : ('a * 'a -> 'a) -> ('a map * 'a map) -> 'a map\n    val unionWithi : (Key.ord_key * 'a * 'a -> 'a) -> ('a map * 'a map) -> 'a map\n    val intersectWith  : ('a * 'a -> 'a) -> ('a map * 'a map) -> 'a map\n    val intersectWithi : (Key.ord_key * 'a * 'a -> 'a) -> ('a map * 'a map) -> 'a map\n    val filter  : ('a -> bool) -> 'a map -> 'a map\n    val filteri : (Key.ord_key * 'a -> bool) -> 'a map -> 'a map\n    val mapPartial  : ('a -> 'b option) -> 'a map -> 'b map\n    val mapPartiali : (Key.ord_key * 'a -> 'b option) -> 'a map -> 'b map\n\nAdded IOUtil : IO_UTIL structure to the Util library.  This provides\nsupport for dynamically rebinding stdIn and stdOut.\n\nAdded KeywordFn functor to the Util library.  This provides support for\nimplementing scanners, where keyword recognition is done outside the\nbasic lexical analysis.\n\nFixed several bugs in the ListSetFn functor.\n\n\n--------------------------------------------------------------------------------\n[1997-01-10] 109.23 --> 109.24\n------------------------------\n\nChanged the HASH_TABLE, MONO_HASH_TABLE, MONO_HASH2_TABLE, and ORD_MAP\ninterfaces to provide two forms of the listItems function.  listItemsi\nreturns a list of (key, value) pairs and listItems returns just the values.\nThe previous version of listItems was like listItemsi.\n\nAdded a missing case for BASEFONT in CheckHTMLFn.check.\n\n\n--------------------------------------------------------------------------------\n[1996-12-07] 109.21.1 --> 109.22\n--------------------------------\n\nChanged the MONO_DYNAMIC_ARRAY signature to make array an eqtype (also changed\nthe implementation of DynamicArrayFn).\n\nFixed a bug in Array2.column\n\n\n--------------------------------------------------------------------------------\n[1996-10-18] 109.19 --> 109.20\n------------------------------\n\nAdded functions for sending/receiving strings over TCP sockets to the\nSockUtil structure.\n\nFixed a bug with reading on a closed socket in SockUtil.sockRecvVec\n\nFixed a bug in the implementation of the intersection operation\nin binary sets (BinarySetFn and IntBinarySet).\n\n\n--------------------------------------------------------------------------------\n[1996-10-01] 109.18 --> 109.19\n------------------------------\n\nUpdated the HTML library to the August 21 version of the 3.2 DTD.\n\nAdded html-defaults.sml to the HTML Library.\n\nAdded Parsing combinators to the Util library.\n\nAdded Socket utilities to the Unix library.\n\n"),
  ("smlnj-lib/TODO", "Utility library\n---------------\n  Polymorphic version of dynamic arrays.\n  New hash table implementation/API.\n\nHTML Library\n------------\n\n  Rewrite parser as recursive descent (the ML-Yacc version doesn't handle\n  whitespace in the HEAD element very well).\n\nPP Library\n----------\n\n  Add support for tabular layout.\n\nRegExp library\n--------------\n\n  Add support for Interval REs to the DFA and Thompson engines\n\n  Add support for \"$\" to the Thompson engine\n\n  Add support for POSIX character classes to the AWK syntax.  These\n  are\n\t[:alnum:]\tAlphanumeric characters. \n\t[:alpha:]\tAlphabetic characters. \n\t[:blank:]\tSpace and TAB characters. \n\t[:cntrl:]\tControl characters. \n\t[:digit:]\tDecimal digits.\n\t[:graph:]\tCharacters that are both printable and visible.\n\t\t\t(A space is printable but not visible, whereas an \226\128\152a\226\128\153 is both.)\n\t[:lower:]\tLowercase alphabetic characters. \n\t[:print:]\tPrintable characters (characters that are not control characters). \n\t[:punct:]\tPunctuation characters (characters that are not letters,\n\t\t\tdigits, control characters, or space characters). \n\t[:space:]\tSpace characters (such as space, TAB, and formfeed, etc). \n\t[:upper:]\tUppercase alphabetic characters. \n\t[:xdigit:]\tHexadecimal digits. \n\nNew libraries\n-------------\n\n  CGI scripting\n"),
  ("ml-lpt/lib/stream-pos.sml", "(* stream-pos.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Very simple position tracking and source maps for ml-ulex/ml-antlr\n *)\n\nstructure AntlrStreamPos :> sig\n\n  type pos = Position.int\n  type span = pos * pos\n  type sourceloc = { fileName : string option, lineNo : int, colNo : int }\n  type sourcemap\n\n  exception PosMustIncrease\n\n  (* the result of moving forward an integer number of characters *)\n  val forward : pos * int -> pos\n\n  val mkSourcemap  : unit   -> sourcemap\n  val mkSourcemap' : string -> sourcemap\n\n  val same : sourcemap * sourcemap -> bool\n\n  (* log a new line occurence *)\n  val markNewLine : sourcemap -> pos -> unit\n  (* resychronize to a full source location *)\n  val resynch     : sourcemap -> pos * sourceloc -> unit\n\n  val sourceLoc\t: sourcemap -> pos -> sourceloc\n  val fileName\t: sourcemap -> pos -> string option\n  val lineNo\t: sourcemap -> pos -> int\n  val colNo\t: sourcemap -> pos -> int\n  val toString\t: sourcemap -> pos -> string\n  val spanToString : sourcemap -> span -> string\n\nend = struct\n\n  type pos = Position.int\n  type span = pos * pos\n  type sourceloc = { fileName : string option, lineNo : int, colNo : int }\n  type sourcemap = (sourceloc * pos) list ref\n\n  exception PosMustIncrease\n\n  fun forward (p, i) = p + (Position.fromInt i)\n\n  fun mkSrcMap fileOpt = ref [\n\t  ({fileName = fileOpt, lineNo = 1, colNo = 0}, Position.fromInt ~1)\n\t]\n\n  fun mkSourcemap () = mkSrcMap NONE\n  fun mkSourcemap' (fname) = mkSrcMap (SOME fname)\n\n  fun same (sm1 : sourcemap, sm2) = (sm1 = sm2)\n\n  fun markNewLine sm (newPos : pos) = let\n        val ({fileName, lineNo, colNo}, pos) = hd (!sm)\n        in\n          if pos < newPos then\n\t    sm := ({ fileName = fileName,\n\t\t     lineNo = lineNo + 1,\n\t\t     colNo = 0}, \n\t\t   newPos)::(!sm)\n\t  else () (* raise PosMustIncrease *)\n        end\n\n  fun resynch sm (newPos : pos, sourceLoc) = let\n        val (_, pos) = hd (!sm)\n        in\n(*          if pos < newPos then *)\n\t    sm := (sourceLoc, newPos)::(!sm)\n(*\t  else raise PosMustIncrease *)\n        end\n\n  fun findLB ((loc, pos)::sm, pos' : pos) = \n        if pos <= pos' then (loc, pos)\n\telse findLB(sm, pos')\n    | findLB _ = raise Fail \"impossible\"\n\n  fun sourceLoc sm pos = let \n        val ({fileName, lineNo, colNo}, anchor) = findLB(!sm, pos)\n        in\n          {fileName = fileName, lineNo = lineNo, \n\t   colNo = colNo + Position.toInt(pos - anchor)}\n        end\n  fun fileName sm pos = #fileName (sourceLoc sm pos)\n  fun lineNo   sm pos = #lineNo   (sourceLoc sm pos)\n  fun colNo    sm pos = #colNo    (sourceLoc sm pos)\n  fun toString sm pos = String.concat [\n\t\"[\", case fileName sm pos\n\t      of NONE => \"\"\n\t       | SOME f => f ^ \":\",\n\t     Int.toString (lineNo sm pos), \".\",\n\t     Int.toString (colNo  sm pos), \"]\"]\n  fun spanToString sm (pos1, pos2) = \n        if lineNo sm pos1 = lineNo sm pos2 andalso\n\t   colNo  sm pos1 = colNo  sm pos2 \n\tthen toString sm pos1\n\telse String.concat [\n  \t  \"[\", case fileName sm pos1\n\t        of NONE => \"\"\n\t         | SOME f => f ^ \":\",\n\t       Int.toString (lineNo sm pos1), \".\",\n\t       Int.toString (colNo  sm pos1), \"-\",\n\t       Int.toString (lineNo sm pos2), \".\",\n\t       Int.toString (colNo  sm pos2), \"]\"]\n\nend\n"),
  ("ml-lpt/lib/antlr-tokens-sig.smi", "_require \"basis.smi\"\n"),
  ("ml-lpt/lib/ebnf.smi", "_require \"basis.smi\"\n_require \"stream-pos.smi\"\n"),
  ("ml-lpt/lib/err-handler.sml", "(* err-handler.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Error repair for ml-antlr\n *)\n\nfunctor AntlrErrHandler (\n    structure Tok : ANTLR_TOKENS\n    structure Lex : ANTLR_LEXER\n  ) : sig\n\n  exception ParseError\n\n  type 'a err_handler\n  type wstream\n  type lexer = Lex.strm -> Tok.token * AntlrStreamPos.span * Lex.strm\n  type 'a wreader = wstream -> 'a * AntlrStreamPos.span * wstream\n\n  val mkErrHandler : { get : unit -> 'a, put : 'a -> unit }\n\t\t     -> 'a err_handler * Tok.token wreader\n  val launch  : 'a err_handler * lexer * 'b wreader * bool ->\n\t        Lex.strm -> ('b option * Lex.strm * Tok.token AntlrRepair.repair list)\n  val failure : 'a err_handler -> 'b\n\n  val getPos    : wstream -> AntlrStreamPos.pos\n  val getSpan   : wstream -> AntlrStreamPos.span\n\n  val whileDisabled : 'b err_handler -> (unit -> 'a) -> 'a \n\n(*\n  val wrap   : err_handler -> (R.strm -> ('a * R.strm)) -> R.strm -> ('a * R.strm)\n  val tryProds : 'b err_handler -> (R.strm -> 'a) list -> R.strm -> 'a\n*)\n\nend = struct\n\n  exception ParseError\n  exception Unrepairable\n\n  structure AR = AntlrRepair\n\n  structure WS = AntlrWrappedStream(\n    structure Tok = Tok\n    structure Lex = Lex)\n\n  type wstream = WS.wstream\n  val getPos = WS.getPos\n  val getSpan = WS.getSpan\n\n  type lexer = Lex.strm -> Tok.token * AntlrStreamPos.span * Lex.strm\n  type 'a wreader = wstream -> 'a * AntlrStreamPos.span * wstream\n  type 'a checkpoint = 'a * unit SMLofNJ.Cont.cont * wstream\n\n  datatype 'a err_handler = EH of {\t\t\t\t  \n    checkpoints : 'a checkpoint list ref,\n    maxPos : WS.tok_pos ref,\n    cont : unit SMLofNJ.Cont.cont option ref,\n    get : unit -> 'a,\n    put : 'a -> unit,\n    rs : WS.repair_state,\n    enabled : bool ref\n  }\n\n  fun getGet (EH {get,  ...}) = get\n  fun getPut (EH {put,  ...}) = put\n  fun getRS  (EH {rs,   ...}) = rs\n\n  fun getCont (EH {cont, ...}) = !cont\n  fun setCont (EH {cont, ...}, new) = cont := new\n\n  fun getCheckpoints (EH {checkpoints,   ...}) = !checkpoints\n  fun setCheckpoints (EH {checkpoints,   ...}, new) = checkpoints := new\n\n  fun getMaxPos (EH {maxPos,   ...}) = !maxPos\n  fun setMaxPos (EH {maxPos,   ...}, new) = maxPos := new\n \n  fun getEnabled (EH {enabled, ...}) = !enabled\n  fun setEnabled (EH {enabled, ...}, n) = enabled := n\n(*\n  fun getRepairs (EH {repairs, ...}) = !repairs \n  fun addRepair  (EH {repairs, ...}, n) = repairs := (!repairs) @ [n] *)\n\n  fun mkErrHandler {get, put} = let\n        val cont = ref NONE\n\tval checkpoints = ref []\n\tval maxPos = ref ~1\n        val eh = EH {\n\t      cont = cont, checkpoints = checkpoints,\n\t      maxPos = maxPos, get = get, put = put,\n\t      rs = WS.mkRepairState(), enabled = ref true\n\t    }\n        fun lex ws = \n\t  if isSome (!cont)\n\t  then (maxPos := Int.max (WS.getTokPos ws, !maxPos);\n\t\tWS.get1 ws)\n\t  else \n\t    if WS.getTokPos ws > !maxPos \n\t    then let\n\t      val () = SMLofNJ.Cont.callcc \n\t\t(fn k => (checkpoints := (get(), k, ws) :: !checkpoints;\n\t\t\t  maxPos := WS.getTokPos ws))\n\t      in\n\t\tWS.get1 ws\n\t      end\n\t    else WS.get1 ws\n        in (eh, lex)\n        end\n\n  val isEOF = Tok.isEOF o #1 o WS.get1\n\n  val minAdvance = 1\n\n  fun restoreCheckpoint (eh, (x, cont, strm)) =\n        (getPut eh x;  (* retore refcell data for checkpoint *)\n\t setMaxPos (eh, WS.getTokPos strm);\n\t SMLofNJ.Cont.throw cont ())\n\n  fun tryRepair (eh, c) = let\n        val oldMax = getMaxPos eh\n\tval firstTime = ref true\n\tval () = SMLofNJ.Cont.callcc (fn k => (setCont (eh, SOME k)))\n        in if !firstTime then \n\t     (* first time through, try the repair *)\n\t     (firstTime := false; restoreCheckpoint (eh, c))\n\t   else\n\t     (* second time through, return the distance achieved *)\n\t     (setCont (eh, NONE); getMaxPos eh - oldMax)\n        end\n\n  local\n\n    val allToks = List.filter (not o Tok.isEOF) Tok.allToks\n    fun mkDelete strm = (WS.getPos strm, AR.Delete [#1 (WS.get1 strm)])\n    fun mkInsert strm tok = (WS.getPos strm, AR.Insert [tok])\n    fun mkSubst  strm tok = (WS.getPos strm, AR.Subst { old = [#1 (WS.get1 strm)], new = [tok] })\n    fun allRepairs strm = \n\t  (if isEOF strm then [] else [mkDelete strm]) @\n\t  map (mkInsert strm) allToks @\n\t  (if isEOF strm then [] else map (mkSubst strm) allToks)\n\n    fun involvesKW (_, r) = (case r\n\t  of AR.Insert toks => List.exists Tok.isKW toks\n\t   | AR.Delete toks => List.exists Tok.isKW toks\n\t   | AR.Subst {old,new} => List.exists Tok.isKW (old @ new)\n\t   | AR.FailureAt _ => false\n         (* end case *))\n\n  in\n  fun trySingleToken eh = let\n\tval RS = getRS eh\n\tval oldRepairs = WS.getRepairs RS\n\tval oldMax = getMaxPos eh\n\tval oldMaxRepair = WS.maxRepairPos RS\n\tval oldCheckpoints = getCheckpoints eh\n\tfun restoreToErr() = (WS.setRepairs (RS, oldRepairs); setMaxPos (eh, oldMax))\n      (* stream value for checkpoint *)\n\tfun strmOf (_, _, strm) = strm\n\tfun setupRepair (r, c::cs) = \n\t      WS.setRepairs (RS, WS.addRepair (oldRepairs, WS.getTokPos (strmOf c), r))\n\t  | setupRepair _ = raise Fail \"bug\"\n\tfun try (_::c::cs, [], best, n) = \n\t      if n < 15 andalso WS.getTokPos (strmOf c) > oldMaxRepair\n\t      then try (c::cs, allRepairs (strmOf c), best, n+1)\n\t      else try ([], [], best, n)\n\t  | try (c::cs, r::rs, best, n) = (\n\t      restoreToErr(); setupRepair (r, c::cs);\n\t      let val score = tryRepair (eh, c) \n\t\t\t        - (if involvesKW r then 2 else 0)\n\t\t\t        + (case #2 r\n\t\t\t\t    of AR.Insert _ => ~1\n\t\t\t\t     | AR.Delete _ => 1\n\t\t\t\t     | AR.Subst  _ => 0\n\t\t\t\t     | _ => 0)\n\t\t  val oldScore = case best of NONE => 0 \n\t\t\t\t\t    | SOME (_, _, s) => s\n\t      in if score > oldScore andalso score > minAdvance\n\t\t then try (c::cs, rs, SOME (c::cs, r, score), n)\n\t\t else try (c::cs, rs, best, n)\n\t      end)\n\t  | try (_, [], SOME (c::cs, r, score), _) = \n\t      (setupRepair (r, c::cs); \n\t       setCheckpoints (eh, c::cs);\n\t       setMaxPos (eh, List.length cs); \n\t       restoreCheckpoint (eh, c))\n\t  | try _ = restoreToErr()\n\tval curStrm = strmOf (hd oldCheckpoints)\n        in if WS.getTokPos curStrm <= WS.maxRepairPos RS then ()\n\t   else try (oldCheckpoints, allRepairs curStrm, NONE, 1)\n        end\n  end\n\n  val maxDel = 50\n\n  fun tryDeletion eh = let\n        fun getn (strm, 0, acc) = SOME (rev acc)\n\t  | getn (strm, n, acc) = let\n\t      val (tok, _, strm') = WS.get1 strm\n\t      in\n\t        if Tok.isEOF tok then NONE\n\t\telse getn (strm', n-1, tok::acc)\n\t      end\n\tval rs = getRS eh\n\tval oldRepairs = WS.getRepairs rs\n\tval oldMax = getMaxPos eh\n\tval oldRepairMax = WS.maxRepairPos rs\n\tfun restoreToErr() = (WS.setRepairs (rs, oldRepairs); setMaxPos (eh, oldMax))\n      (* stream value for checkpoint *)\n\tfun strmOf (_, _, strm) = strm\n\tval cs = getCheckpoints eh\n\tfun tryCS ([], n, max) = ()\n\t  | tryCS (c::cs, n, max) = \n\t      if WS.getTokPos (strmOf c) <= oldRepairMax \n\t         orelse oldMax - WS.getTokPos (strmOf c) > maxDel then () \n\t      else\n\t        (WS.setRepairs (rs, \n\t\t   WS.addRepair (oldRepairs, WS.getTokPos (strmOf c),\n\t             (WS.getPos (strmOf c), AR.Delete (valOf (getn (strmOf c, n, []))))));\n\t\t setMaxPos (eh, WS.getTokPos (strmOf c));\n\t\t if tryRepair (eh, c) > minAdvance + 2\n\t\t then (setCheckpoints (eh, c::cs); \n\t\t       restoreCheckpoint (eh, c))\n\t\t else (restoreToErr(); tryCS (cs, n+1, max)))\n\tand tryN (n, c::cs, max) = (case getn (strmOf c, n, [])\n              of NONE => ()\n\t       | SOME toks => (tryCS (c::cs, n, max);\n\t\t\t       if n > max then () else tryN (n+1, c::cs, max))\n             (* end case *))\n\t  | tryN _ = raise Fail \"bug\"\n        in \n          tryN (1, [hd cs], 5);\n\t  tryN (1, cs, maxDel)\n        end\n\n  fun failure eh = \n        if getEnabled eh \n\tthen (case getCont eh\n               of NONE => (trySingleToken eh;\n\t\t\t   tryDeletion eh;\n\t\t\t   raise Unrepairable)\n\t\t| SOME k => SMLofNJ.Cont.throw k ()\n\t      (* end case *))\n\telse raise ParseError\n\n  fun launch (eh, lex, parse, reqEOF) strm = let\n\tval wstrm = WS.wrap (getRS eh, strm, lex)\n        in let val (result, _, wstrm') = parse wstrm\n\t       val (strm', repairs) = WS.unwrap wstrm'\n\t   in \n\t     if reqEOF andalso not (isEOF wstrm') then failure eh\n\t     else ();\n\t     (SOME result, strm', repairs) \n\t   end\n\t   handle Unrepairable => let\n\t     val (_, repairs) = WS.unwrap wstrm\n\t     val (tok, (pos, _), _) = (WS.get1 o #3 o hd o getCheckpoints) eh\n\t     in (NONE, strm, repairs @ [(pos, AR.FailureAt tok)]) end\n        end\n\n  fun whileDisabled eh f = let\n        val oldEnabled = getEnabled eh\n        in\n\t  setEnabled (eh, false);\n\t  (f () handle e => (setEnabled (eh, oldEnabled);\n\t\t\t     raise e))\n\t  before setEnabled (eh, oldEnabled)\n        end\n\n(*\n  fun throwIfEH (eh, t) = \n        if getEnabled eh then \n\t  Option.app (fn k => SMLofNJ.Cont.throw k (SOME t)) (getCont eh)\n\telse ()\n\n  fun wrap eh f t = if not (getEnabled eh) then f t else let\n\tval cont_ref : retry_cont option ref = ref NONE\n\tval state = (getGet eh) () \n\tval t' = SMLofNJ.Cont.callcc (fn k => (cont_ref := SOME k; t))\n\tval retry = (t', valOf (!cont_ref)) \n        in\n\t  getPut eh state; \n\t  f t'\n\t  handle RepairableError => (\n\t    throwIfEH (eh, t');\n\t    raise JumpOut [retry])\n\t| JumpOut stack => (\n\t    throwIfEH (eh, t');\n\t    raise JumpOut (retry::stack))\n        end\n\n  fun findWindow (stack) = let\n\tval revStack = rev stack\n\tval rightMost = hd revStack\n\tfun TOf (t, _) = t\n\tfun find [] = raise (Fail \"BUG: findWindow given an empty stack\")\n\t  | find [top] = (top, rightMost)\n\t  | find (top::stack) = \n\t      if R.farEnoughWindow {startAt = TOf top, endAt = TOf rightMost}\n\t      then (top, rightMost)\n\t      else find stack\n        in\n\t  find revStack\n        end\n\n  fun tryRepair (eh, cont) t = \n        (case SMLofNJ.Cont.callcc (fn k => (setCont (eh, SOME k); NONE))\n\t  of NONE => \n\t     (* first time through, try the repair *)\n\t       SMLofNJ.Cont.throw cont t\n\t   | SOME t' => \n\t     (* second time through, return the new right-most strm *)\n\t       (setCont (eh, NONE); t')\n\t (* end case *))\n\n  fun primaryRepair (eh, stack) = let\n\tval ((leftT, leftCont), (rightT, rightCont)) = \n\t    findWindow stack\n\tval repair = R.chooseRepair {\n\t\t\tstartAt = leftT,\n\t\t\tendAt = rightT,\n\t\t\ttry = tryRepair (eh, leftCont)\n\t\t     }\n        in case repair\n\t    of SOME {repair, repaired} => \n\t         SOME (repair, leftCont, repaired)\n\t     | NONE => NONE\n        end\n\n  fun secondaryRepair (eh, revStack) = let\n\tval stack = rev revStack\n\tval (errStrm, errCont) = hd stack\n\tfun try ((strm, cont), strm', next) = let\n\t      val strm'' = tryRepair (eh, cont) strm'\n    \t      in case (R.tryDeletion {oldStartAt = strm, \n\t\t\t\t      startAt = strm', \n\t\t\t\t      endAt = strm''})\n\t\t  of SOME r => SOME (r, cont, strm')\n\t\t   | NONE => next()\n\t      end\n\tfun rightRepair (strm, n) = \n\t      if n = 0 then NONE\n\t      else let \n\t        val strm' = R.skip (strm, 1)\n\t\tin \n\t\t  try (hd stack, strm', fn () => rightRepair (strm', n-1))\n\t\tend\n\tfun leftRightRepair (strm, []) = \n\t      if R.isEmpty strm then\n\t\t(addRepair (eh, (R.getPos errStrm, \n\t\t\t\t Repair.FailureAt (#1 (R.get1 errStrm))));\n\t\t raise UnrepairableError)\n\t      else leftRightRepair (R.skip (strm, 1), stack)\n\t  | leftRightRepair (strm, top::stack) = \n\t      try (top, strm, fn () => leftRightRepair (strm, stack))\n        in case rightRepair (errStrm, 5)\n\t    of SOME r => r\n\t     | _      => valOf (leftRightRepair (errStrm, []))\n        end\n\n  fun repair (eh, stack) = (case primaryRepair (eh, stack)\n\tof SOME r => r\n\t | NONE => secondaryRepair (eh, stack)\n       (* end case *))\n\n  fun launch eh f t = let\n        val (x, _, t') = wrap eh f t \n\t    handle JumpOut stack => let\n\t        val (r, cont, t') = repair (eh, stack)\n\t\tin\n\t\t  addRepair (eh, r);\n\t\t  SMLofNJ.Cont.throw cont t'\n\t\tend\n        in\n\t  throwIfEH (eh, t');\n\t  (SOME x, t', getRepairs eh)\n        end\n    handle UnrepairableError =>\n      (NONE, t, getRepairs eh)\n*)\n\n(*\n  fun tryProds eh prods strm = let\n\tfun try [] = raise RepairableError\n\t  | try (prod :: prods) = let \n\t      val state = (getGet eh) ()\n\t      in\n\t        whileDisabled eh (fn () => prod strm)\n\t\thandle _ => \n\t\t  (getPut eh state;\n\t\t   try (prods))\n\t      end\n        in\n          try prods\n        end\n*)\n\nend\n"),
  ("ml-lpt/lib/wrapped-strm.sml", "(* wrapped-strm.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * \"wrapped\" streams, which track the number of tokens read\n * and allow \"prepending\" a sequence of tokens.\n *)\n\nfunctor AntlrWrappedStream (\n    structure Tok : ANTLR_TOKENS\n    structure Lex : ANTLR_LEXER\n  ) :> sig\n\n  type tok_pos = Int.int\t(* position in terms of number of tokens *)\n  type lexer = Lex.strm -> Tok.token * AntlrStreamPos.span * Lex.strm\n\n  type repairs\n  val addRepair : repairs * tok_pos * Tok.token AntlrRepair.repair -> repairs\n\n  type repair_state\n  val mkRepairState : unit -> repair_state\n  val getRepairs : repair_state -> repairs\n  val setRepairs : repair_state * repairs -> unit\n  val maxRepairPos : repair_state -> tok_pos\n\n  type wstream\n  val wrap   : repair_state * Lex.strm * lexer -> wstream\n  val unwrap : wstream -> Lex.strm * Tok.token AntlrRepair.repair list\n\n  val get1      : wstream -> Tok.token * AntlrStreamPos.span * wstream\n  val getPos    : wstream -> AntlrStreamPos.pos\n  val getSpan   : wstream -> AntlrStreamPos.span\n  val getTokPos : wstream -> tok_pos\n\nend = struct\n\n  type tok_pos = Int.int\t(* position in terms of number of tokens *)\n  type repair = tok_pos * Tok.token AntlrRepair.repair\n  type repairs = repair list\n  type repair_state = repairs ref (* invariant: at most one repair per tok_pos *)\n  type lexer = Lex.strm -> Tok.token * AntlrStreamPos.span * Lex.strm\n\n  datatype global_state = GS of {\n    lex : (Lex.strm -> Tok.token * AntlrStreamPos.span * Lex.strm),\n    repairs : repair_state\n  }\n\n  datatype wstream = WSTREAM of {\n    curTok : tok_pos,\n    strm : Lex.strm,\n    gs : global_state\n  }\n\n  fun mkRepairState() = ref []\n  fun getRepairs repairs = !repairs\n  fun setRepairs (repairs, new) = repairs := new\n  fun maxRepairPos (ref []) = ~1\n    | maxRepairPos (ref ((p, _)::_)) = p\n\n  open AntlrRepair\n\n  fun addRepair (rs, pos, r) =\n        if pos > maxRepairPos (ref rs) then (pos, r)::rs\n\telse raise Fail (String.concat [\n\t\t\"bug: repairs not monotonic adding at \",\n\t\tInt.toString pos, \" to a max pos of \",\n\t\tInt.toString (maxRepairPos (ref rs))])\n\n  fun wrap (repairs, strm, lex) = \n        WSTREAM {strm = strm, curTok = 0, gs = GS {lex = lex, repairs = repairs}}\n  fun unwrap (WSTREAM {strm, gs = GS {repairs, ...}, ...}) = \n        (strm, rev (#2 (ListPair.unzip (!repairs))))\n\n  fun skip1 lex strm = let \n        val (_, _, strm') = lex strm \n        in strm' end\n  fun get1 (WSTREAM {strm, curTok, gs = gs as GS {lex, repairs}}) = let\n        fun findRepair [] = NONE\n\t  | findRepair ((pos, r)::rs) = if curTok = pos then SOME r \n\t\t\t\t\telse findRepair rs\n        in case findRepair (!repairs)\n\t    of NONE => let\n\t\t val (tok, span, strm') = lex strm\n\t         in \n\t\t   (tok, span, WSTREAM {strm = strm', curTok = curTok + 1, gs = gs})\n\t         end\n\t     | SOME (p, Insert [tok]) => \n\t         (tok, (p, p), WSTREAM {strm = strm, curTok = curTok + 1, gs = gs})\n\t     | SOME (p, Delete toks) => let\n\t\t val strm' = foldl (fn (_, s) => (skip1 lex) s) strm toks\n\t\t val (tok, span, strm'') = lex strm'\n\t         in \n\t\t   (tok, span, WSTREAM {strm = strm'', curTok = curTok + 1, gs = gs})\n\t         end\n\t     | SOME (p, Subst {old = [old], new = [new]}) => \n\t         (new, (p, p), WSTREAM {strm = skip1 lex strm, curTok = curTok + 1, gs = gs})\n\t     | SOME (p, FailureAt _) => raise Fail \"bug: findRepair found FailureAt\"\n\t     | _ => raise Fail \"bug: unimplemented\"\n        end\n\n  (* get position AFTER trimming whitespace *)\n  fun getPos ws = let val (_, (left, _), _) = get1 ws in left end\n  fun getSpan ws = (getPos ws, getPos ws)\n  fun getTokPos (WSTREAM {curTok, ...}) = curTok\n        \n\nend\n"),
  ("ml-lpt/lib/err-handler.smi", "_require \"basis.smi\"\n"),
  ("ml-lpt/lib/wrapped-strm.smi", "_require \"basis.smi\"\n_require \"antlr-tokens-sig.sml\"\n_require \"antlr-lexer-sig.sml\"\n_require \"stream-pos.smi\"\n_require \"repair.smi\"\n"),
  ("ml-lpt/lib/ulex-buffer.sml", "(* ulex-buffer.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Forward-chained buffers for lexing\n *)\n\nstructure ULexBuffer : sig\n\n    type stream\n\n    exception Incomplete\t(* raised by getu on an incomplete multi-byte character *)\n\n    val mkStream : (AntlrStreamPos.pos * (unit -> string)) -> stream\n    val getc : stream -> (char * stream) option\n    val getu : stream -> (word * stream) option\n    val getpos : stream -> AntlrStreamPos.pos\n    val subtract : stream * stream -> Substring.substring\n    val eof : stream -> bool\n    val lastWasNL : stream -> bool\n\n  end = struct\n\n    structure W = Word\n\n    datatype stream = S of (buf * int * bool) \n    and buf = B of { \n      data : string,\n      basePos : AntlrStreamPos.pos,\n      more : more ref,\n      input : unit -> string\n    }\n    and more = UNKNOWN | YES of buf | NO\n        \n    fun mkStream (pos, input) = \n\t  (S (B {data = \"\", basePos = pos, \n\t\t more = ref UNKNOWN,\n\t\t input = input},\n\t      0, true))\n\n  (* advance the stream to the next block of input *)\n    fun advance (data, input, basePos, more) = (case !more\n\t   of UNKNOWN => (case input()\n\t\t of \"\" => (more := NO; NO)\n\t\t  | data' => let \n\t\t      val buf' = B {\n\t\t\t  data = data',\n\t\t\t  basePos = AntlrStreamPos.forward (basePos, String.size data),\n\t\t\t  more = ref UNKNOWN,\n\t\t\t  input = input\n\t\t\t}\n\t\t      in\n\t\t\tmore := YES buf';\n\t\t\tYES buf'\n\t\t      end\n\t\t(* end case *))\n\t    | m => m\n\t  (* end case *))\n\n    fun getc (S(buf as B{data, basePos, more, input}, pos, lastWasNL)) = \n\t  if pos < String.size data\n\t    then let\n\t      val c = String.sub (data, pos)\n\t      in\n\t\tSOME (c, S (buf, pos+1, c = #\"\\n\"))\n\t      end\n\t    else (case advance(data, input, basePos, more)\n\t       of NO => NONE\n\t\t| YES buf' => getc (S (buf', 0, lastWasNL))\n\t\t| UNKNOWN => raise Fail \"impossible\"\n\t      (* end case *))\n\n    exception Incomplete\n\n  (* get the next UTF8 character represented as a word *)\n    fun getu (S(buf as B{data, basePos, more, input}, pos, _)) =\n\t  if pos < String.size data\n\t    then let\n\t      val c = W.fromInt(Char.ord(String.sub(data, pos)))\n\t      in\n\t\tif (c < 0w128)\n\t\t  then SOME(c, S(buf, pos+1, c = 0w10))  (* ord #\"\\n\" = 10 *)\n\t\t  else let (* multibyte character *)\n\t\t    fun getByte (S(buf as B{data, basePos, more, input}, pos, _)) = \n\t\t\t  if pos < String.size data\n\t\t\t    then let\n\t\t\t      val c = W.fromInt(Char.ord(String.sub(data, pos)))\n\t\t\t      in\n\t\t\t\tSOME (c, S (buf, pos+1, false))\n\t\t\t      end\n\t\t\t    else (case advance(data, input, basePos, more)\n\t\t\t       of NO => NONE\n\t\t\t\t| YES buf' => getByte (S (buf', 0, false))\n\t\t\t\t| UNKNOWN => raise Fail \"impossible\"\n\t\t\t      (* end case *))\n\t\t    fun getContByte (wc, strm) = (case getByte strm\n\t\t\t   of NONE => raise Incomplete\n\t\t\t    | SOME(b, strm') => if (W.andb(0wxc0, b) = 0wx80)\n\t\t\t\tthen (W.orb(W.<<(wc, 0w6), W.andb(0wx3f, b)), strm')\n\t\t\t\telse raise Incomplete\n\t\t\t  (* end case *))\n\t\t    val strm = S(buf, pos+1, false)\n\t\t    in\n\t\t      case (W.andb(0wxe0, c))\n\t\t       of 0wxc0 => SOME(getContByte (W.andb(0wx1f, c), strm))\n\t\t\t| 0wxe0 => SOME(getContByte(getContByte(W.andb(0wx0f, c), strm)))\n\t\t\t| _ => raise Incomplete\n\t\t      (* end case *)\n\t\t    end\n\t      end\n\t  (* advance buffer *)\n\t    else (case advance(data, input, basePos, more)\n\t       of NO => NONE\n\t\t| YES buf' => getu (S(buf', 0, false))\n\t\t| UNKNOWN => raise Fail \"impossible\"\n\t      (* end case *))\n\n    fun getpos (S (B {basePos, ...}, pos, _)) = AntlrStreamPos.forward (basePos, pos)\n\n    fun subtract (new, old) = let\n\t  val (S (B {data = ndata, basePos = nbasePos, ...}, npos, _)) = new\n\t  val (S (B {data = odata, basePos = obasePos, \n\t\t     more, input}, opos, _)) = old\n\t  in\n\t    if nbasePos = obasePos then\n\t      Substring.substring (ndata, opos, npos-opos)\n\t    else case !more\n\t\t  of NO =>      raise Fail \"BUG: ULexBuffer.subtract, but buffers are unrelated\"\n\t\t   | UNKNOWN => raise Fail \"BUG: ULexBuffer.subtract, but buffers are unrelated\"\n\t\t   | YES buf => \n\t\t       Substring.extract (\n\t\t\t Substring.concat [\n\t\t\t   Substring.extract (odata, opos, NONE),\n\t\t\t   subtract (new, S (buf, 0, false))],\n\t\t\t 0, NONE)\n\t  end\n\n    fun eof s = not (isSome (getc s))\n\n    fun lastWasNL (S (_, _, lastWasNL)) = lastWasNL\n\n  end"),
  ("ml-lpt/lib/repair.smi", "_require \"basis.smi\"\n_require \"stream-pos.smi\"\n\nstructure AntlrRepair =\n  struct\n\n    datatype 'tok repair_action\n      = Insert of 'tok list\n      | Delete of 'tok list\n      | Subst of {\n          old : 'tok list, \n          new : 'tok list\n        }\n      | FailureAt of 'tok\n\n    type 'tok repair = AntlrStreamPos.pos * 'tok repair_action\n\n    val actionToString : ('tok -> string) -> 'tok repair_action -> string\n    val repairToString : ('tok -> string) -> AntlrStreamPos.sourcemap -> 'tok repair -> string\n\nend\n\n"),
  ("ml-lpt/lib/ulex-buffer.smi", "_require \"basis.smi\"\n_require \"stream-pos.smi\"\n\nstructure ULexBuffer =\nstruct\n\n    type stream (= boxed)\n\n    exception Incomplete\t(* raised by getu on an incomplete multi-byte character *)\n\n    val mkStream : (AntlrStreamPos.pos * (unit -> string)) -> stream\n    val getc : stream -> (char * stream) option\n    val getu : stream -> (word * stream) option\n    val getpos : stream -> AntlrStreamPos.pos\n    val subtract : stream * stream -> Substring.substring\n    val eof : stream -> bool\n    val lastWasNL : stream -> bool\n\n  end\n"),
  ("ml-lpt/lib/antlr-lexer-sig.smi", "_require \"basis.smi\"\n_require \"stream-pos.smi\"\n"),
  ("ml-lpt/lib/antlr-tokens-sig.sml", "(* antlr-tokens-sig.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Signature for generated tokens module, for ml-antlr\n *)\n\nsignature ANTLR_TOKENS = sig\n\n  type token\n  \n  val allToks : token list\n  val isKW    : token -> bool\n  val isEOF   : token -> bool\n  val toString : token -> string\n\nend"),
  ("ml-lpt/lib/stream-pos.smi", "_require \"basis.smi\"\n\nstructure AntlrStreamPos  = \n struct \n  type pos = Position.int\n  type span = pos * pos\n  type sourceloc (= boxed)\n  type sourcemap (= boxed)\n\n  exception PosMustIncrease\n\n  (* the result of moving forward an integer number of characters *)\n  val forward : pos * int -> pos\n\n  val mkSourcemap  : unit   -> sourcemap\n  val mkSourcemap' : string -> sourcemap\n\n  val same : sourcemap * sourcemap -> bool\n\n  (* log a new line occurence *)\n  val markNewLine : sourcemap -> pos -> unit\n  (* resychronize to a full source location *)\n  val resynch     : sourcemap -> pos * sourceloc -> unit\n\n  val sourceLoc\t: sourcemap -> pos -> sourceloc\n  val fileName\t: sourcemap -> pos -> string option\n  val lineNo\t: sourcemap -> pos -> int\n  val colNo\t: sourcemap -> pos -> int\n  val toString\t: sourcemap -> pos -> string\n  val spanToString : sourcemap -> span -> string\n\n end \n"),
  ("ml-lpt/lib/mllpt-lib.mlb", "ml-lpt-lib.mlb\n"),
  ("ml-lpt/lib/antlr-lexer-sig.sml", "(* antlr-lexer-sig.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Signature for the lexer argument to parser functors generated\n * by ml-antlr.\n *)\n\nsignature ANTLR_LEXER = sig\n\n  type strm\n  type pos = AntlrStreamPos.pos\n\n  val getPos : strm -> pos\n\nend"),
  ("ml-lpt/lib/ebnf.sml", "(* ebnf.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * EBNF combinators used for ml-antlr.\n *)\n\nfunctor AntlrEBNF (S : sig \n\t\t     type strm\n\t\t     val getSpan : strm -> AntlrStreamPos.span\n    \t           end) = \nstruct\n\n  fun optional (pred, parse, strm) = \n        if pred strm\n    \tthen let\n\t  val (y, span, strm') = parse strm\n\t  in \n\t    (SOME y, span, strm')\n\t  end\n\telse (NONE, S.getSpan strm, strm)\n\n  fun closure (pred, parse, strm) = let\n        fun iter (strm, (left, right), ys) = \n\t      if pred strm\n\t      then let\n\t\tval (y, (_, right'), strm') = parse strm\n\t\tin iter (strm', (left, right'), y::ys)\n\t\tend\n\t      else (List.rev ys, (left, right), strm)\n        in\n          iter (strm, S.getSpan strm, [])\n        end\n\n  fun posclos (pred, parse, strm) = let\n        val (y, (left, _), strm') = parse strm\n\tval (ys, (_, right), strm'') = closure (pred, parse, strm')\n        in\n          (y::ys, (left, right), strm'')\n        end\n\nend"),
  ("ml-lpt/lib/repair.sml", "(* repair.sml\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Representation and pretty-printing of ml-antlr repair actions\n *)\n\nstructure AntlrRepair :> sig\n\n    datatype 'tok repair_action\n      = Insert of 'tok list\n      | Delete of 'tok list\n      | Subst of {\n          old : 'tok list, \n          new : 'tok list\n        }\n      | FailureAt of 'tok\n\n    type 'tok repair = AntlrStreamPos.pos * 'tok repair_action\n\n    val actionToString : ('tok -> string) -> 'tok repair_action -> string\n    val repairToString : ('tok -> string) -> AntlrStreamPos.sourcemap -> 'tok repair -> string\n\n  end = struct\n\n    datatype 'a repair_action\n      = Insert of 'a list\n      | Delete of 'a list\n      | Subst of {\n          old : 'a list, \n          new : 'a list\n        }\n      | FailureAt of 'a\n\n    type 'a repair = AntlrStreamPos.pos * 'a repair_action\n\n    fun actionToString tokToString repair = let\n          val toksToString = (String.concatWith \" \") o (map tokToString)\n          in\n            case repair\n             of Insert toks => \"try inserting \" ^ toksToString toks\n              | Delete toks => \"try deleting \" ^ toksToString toks\n              | Subst {old, new} => concat[\n                    \"try substituting \", toksToString new, \" for \", toksToString old\n                  ]\n              | FailureAt tok => \"syntax error at \" ^ tokToString tok\n            (* end case *)\n          end\n\n    fun repairToString tokToString sm (pos, repair) = \n          (AntlrStreamPos.toString sm pos ^ \": \" ^ actionToString tokToString repair)\n\nend"),
  ("ml-lpt/lib/ml-lpt-lib.cm", "(* ml-lpt-lib.cm\n *\n * COPYRIGHT (c) 2006\n * John Reppy (http://www.cs.uchicago.edu/~jhr)\n * Aaron Turon (http://www.cs.uchicago.edu/~adrassi)\n * All rights reserved.\n *\n * Sources file for ml-lpt lib\n *)\n\nLibrary\n\n  signature ANTLR_LEXER\n  signature ANTLR_TOKENS\n\n  structure AntlrRepair\n  structure AntlrStreamPos\n  structure ULexBuffer\n  structure UTF8 (* from smlnj-lib.cm; used in generated scanners *)\n\n  functor AntlrEBNF\n  functor AntlrErrHandler\n\nis\n\n  $/basis.cm\n  $/smlnj-lib.cm\n  ebnf.sml\n  err-handler.sml\n  antlr-lexer-sig.sml\n  repair.sml\n\n(*\n  repairable-strm-sig.sml\n  repairable-strm.sml\n*)\n  wrapped-strm.sml\n\n  stream-pos.sml\n  antlr-tokens-sig.sml\n\n  ulex-buffer.sml"),
  ("ml-lpt/lib/ml-lpt-lib.mlb", "\nann\n  \"nonexhaustiveMatch warn\" \"redundantMatch warn\"\n  \"sequenceNonUnit ignore\"\n  \"warnUnused false\" \"forceUsed\"\nin\n\nlocal\n  basis l8 =\n    bas\n      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/sml-nj.mlb\n    end\n  basis l62 =\n    bas\n      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb\n    end\nin\nlocal\n   $(SML_LIB)/basis/pervasive.mlb\n   local\n      antlr-tokens-sig.sml\n   in\n      signature gs_0 = ANTLR_TOKENS\n   end\n   local\n      open l8\n   in\n      structure gs_1 = String\n   end\n   local\n      open l8\n   in\n      structure gs_2 = Position\n   end\n   local\n      open l8\n   in\n      structure gs_3 = Int\n   end\n   local\n      structure Int = gs_3\n      structure Position = gs_2\n      structure String = gs_1\n      stream-pos.sml\n   in\n      structure gs_4 = AntlrStreamPos\n   end\n   local\n      structure AntlrStreamPos = gs_4\n      structure String = gs_1\n      repair.sml\n   in\n      structure gs_5 = AntlrRepair\n   end\n   local\n      open l8\n   in\n      structure gs_6 = List\n   end\n   local\n      structure AntlrStreamPos = gs_4\n      structure List = gs_6\n      ebnf.sml\n   in\n      functor gs_7 = AntlrEBNF\n   end\n   local\n      structure AntlrStreamPos = gs_4\n      antlr-lexer-sig.sml\n   in\n      signature gs_8 = ANTLR_LEXER\n   end\n   local\n      open l8\n   in\n      structure gs_9 = SMLofNJ\n   end\n   local\n      open l8\n   in\n      structure gs_10 = ListPair\n   end\n   local\n      signature ANTLR_LEXER = gs_8\n      signature ANTLR_TOKENS = gs_0\n      structure AntlrRepair = gs_5\n      structure AntlrStreamPos = gs_4\n      structure Int = gs_3\n      structure ListPair = gs_10\n      structure String = gs_1\n      wrapped-strm.sml\n   in\n      functor gs_11 = AntlrWrappedStream\n   end\n   local\n      signature ANTLR_LEXER = gs_8\n      signature ANTLR_TOKENS = gs_0\n      structure AntlrRepair = gs_5\n      structure AntlrStreamPos = gs_4\n      functor AntlrWrappedStream = gs_11\n      structure Int = gs_3\n      structure List = gs_6\n      structure SMLofNJ = gs_9\n      err-handler.sml\n   in\n      functor gs_12 = AntlrErrHandler\n   end\n   local\n      open l8\n   in\n      structure gs_13 = Word\n   end\n   local\n      open l8\n   in\n      structure gs_14 = Substring\n   end\n   local\n      open l8\n   in\n      structure gs_15 = Char\n   end\n   local\n      structure AntlrStreamPos = gs_4\n      structure Char = gs_15\n      structure String = gs_1\n      structure Substring = gs_14\n      structure Word = gs_13\n      ulex-buffer.sml\n   in\n      structure gs_16 = ULexBuffer\n   end\n   local\n      open l62\n   in\n      structure gs_17 = UTF8\n   end\nin\n   signature ANTLR_LEXER = gs_8\n   signature ANTLR_TOKENS = gs_0\n   functor AntlrEBNF = gs_7\n   functor AntlrErrHandler = gs_12\n   structure AntlrRepair = gs_5\n   structure AntlrStreamPos = gs_4\n   structure ULexBuffer = gs_16\n   structure UTF8 = gs_17\nend\nend\n\nend\n"),
  ("ml-lpt/lib/ml-lpt-lib.smi", "include \"antlr-lexer-sig.smi\"\ninclude \"antlr-tokens-sig.smi\"\ninclude \"ebnf.smi\"\ninclude \"repair.smi\"\ninclude \"stream-pos.smi\"\ninclude \"ulex-buffer.smi\"\ninclude \"wrapped-strm.smi\"\n"),
  ("scan.ulex.m4", "ifdef(`PROGLR_TOKEN_STR', , `define(`PROGLR_TOKEN_STR', `Token')')\n\n%defs (\n  open PROGLR_TOKEN_STR\n  type lex_result = PROGLR_TOKEN_STR.token\n  val eof = fn () => PROGLR_TOKEN_STR.EOF\n  fun unescape s = case (String.fromCString s) of NONE => s | SOME s' => s'\n);\n\n%name Lexer;\n%states INITIAL IN_CHAR IN_STRING ;\n\n%let digit = [0-9];\n%let char = [\\u0020-\\u007e];\n%let letter = [a-zA-Z\\u00c0-\\u00ff] & [^\\u00d7\\u00f7];\n%let space = [ \\t\\r\\n];\n%let apos = ['];\n%let quot = [\"];\n%let backslash = [\\\\];\n\nifdef(`PROGLR_USE_INTEGER', `\n(* Integer of integers, defined digit+ *)\n<INITIAL> {digit}+ => (Integer (Option.valOf (Int.fromString (yytext))));\n')\n\nifdef(`PROGLR_USE_DOUBLE', `\n(* Double of floating point numbers, defined digit+ \226\128\153.\226\128\153 digit+ (\226\128\153e\226\128\153 \226\128\153-\226\128\153? digit+)? *)\n<INITIAL> {digit}+ \".\" {digit}+ (\"e\" \"-\"? {digit}+)? => (Double (Option.valOf (Real.fromString (yytext))));\n')\n\nifdef(`PROGLR_USE_CHAR', `\n(* Char of characters (in single quotes), defined \226\128\153\\\226\128\153\226\128\153 ((char - [\"\226\128\153\\\\\"]) | (\226\128\153\\\\\226\128\153 [\"\226\128\153\\\\nt\"])) \226\128\153\\\226\128\153\226\128\153 *)\n<INITIAL> {apos} => (YYBEGIN IN_CHAR; continue ());\n<IN_CHAR> ( ({char} & [^\\u0027\\\\]) | ({backslash}[\\u0027\\\\nt]) ) => (Char (Option.valOf (Char.fromCString yytext)));\n<IN_CHAR> {apos} => (YYBEGIN INITIAL; continue ());\n')\n\nifdef(`PROGLR_USE_STRING', `\n(* String of strings (in double quotes), defined \226\128\153\"\226\128\153 ((char - [\"\\\"\\\\\"]) | (\226\128\153\\\\\226\128\153 [\"\\\"\\\\nt\"]))* \226\128\153\"\226\128\153 *)\n<INITIAL> {quot}{2} => (String \"\");\n<INITIAL> {quot} => (YYBEGIN IN_STRING; continue ());\n<IN_STRING> ( ({char} & [^\"\\\\]) | ({backslash}[\"\\\\nt]) )+ => (String (unescape yytext)); \n<IN_STRING> {quot} => (YYBEGIN INITIAL; continue ());\n')\n\nifdef(`PROGLR_USE_IDENT', `\n(* Ident of identifiers, defined letter (letter | digit | \226\128\153_\226\128\153 | \226\128\153\\\226\128\153\226\128\153)* *)\n<INITIAL> {letter} ({letter} | {digit} | \"_\" | \"\\u0027\")* => (Ident yytext);\n')\n\ndefine(`block_comments',`ifelse($2,,,`<INITIAL> \"$1\" .* \"$2\"=> (continue ());\nblock_comments(shift(shift($@)))')')\nblock_comments(PROGLR_BLOCK_COMMENT)\n\ndefine(`line_comments',`ifelse($1,,,`<INITIAL> \"$1\" [^\\n]* [\\n] => (continue ());\nline_comments(shift($@))')')\nline_comments(PROGLR_LINE_COMMENT)\n\ndefine(`keywords',`ifelse($2,,,`<INITIAL> \"$2\" => ($1);\nkeywords(shift(shift($@)))')')\nkeywords(PROGLR_KEYWORDS)\n\n<INITIAL> {space}+ => (continue ());\n"),
  ("main.sml.m4", "structure Parse = ParseFun(Lexer)\n\nopen Parse.Ast\n\nstructure Main = struct\n  fun main (_, arguments) =\n       let\n         val fileName = case arguments of [] => NONE | a::_ => SOME a\n         val ins = case fileName of\n                        NONE => TextIO.stdIn\n                      | SOME name => TextIO.openIn name\n         fun release () =\n               if Option.isSome fileName then TextIO.closeIn ins else ()\n       in\n         let\n           val strm = Lexer.streamifyInstream ins\n           val sourcemap = case fileName of\n                                NONE => AntlrStreamPos.mkSourcemap ()\n                              | SOME n => AntlrStreamPos.mkSourcemap' n\n           val trees = Parse.parse sourcemap strm\n           val numParses = length trees\n         in\n           print (Int.toString numParses ^ \" parse(s)\\n\");\n           release ();\n           OS.Process.success\n         end\n         handle e => (release (); raise e)\n       end\nend\n\nifelse(PROGLR_COMPILER,`mlton', `define(`PROGLR_MAIN_FUN')')\nifelse(PROGLR_COMPILER,`mlkit', `define(`PROGLR_MAIN_FUN')')\nifelse(PROGLR_COMPILER,`poly', `define(`PROGLR_MAIN_FUN')')\nifelse(PROGLR_COMPILER,`alice', `define(`PROGLR_MAIN_FUN')')\n\nifdef(`PROGLR_MAIN_FUN',`\nfun main () =\n  let\n    val name = CommandLine.name ()\n    val arguments = CommandLine.arguments ()\n  in\n      OS.Process.exit (Main.main (name, arguments))\n  end\n')\n\nifelse(PROGLR_COMPILER,`mlton', `define(`PROGLR_BOOT_VAL')')\nifelse(PROGLR_COMPILER,`mlkit', `define(`PROGLR_BOOT_VAL')')\nifelse(PROGLR_COMPILER,`alice', `define(`PROGLR_BOOT_VAL')')\n\nifdef(`PROGLR_BOOT_VAL',`\nval _ = main ()\n')\n"),
  ("main.mlb.m4", "ifdef(`PROGLR_PARSE_SML', , `define(`PROGLR_PARSE_SML', `')')\nifdef(`PROGLR_SCAN_SML', , `define(`PROGLR_SCAN_SML', `')')\nifdef(`PROGLR_MAIN_SML', , `define(`PROGLR_MAIN_SML', `main.sml')')\n\n$(SML_LIB)/basis/basis.mlb\n\nifelse(PROGLR_COMPILER, `mlton',\n$(SML_LIB)/smlnj-lib/smlnj-lib.mlb\n$(SML_LIB)/mllpt-lib/mllpt-lib.mlb\n)\n\nifelse(PROGLR_COMPILER, `mlkit',\nsmlnj-lib/Util/utf8.mlb\nml-lpt/lib/stream-pos.sml\nml-lpt/lib/antlr-lexer-sig.sml\nml-lpt/lib/antlr-tokens-sig.sml\nml-lpt/lib/ebnf.sml\nml-lpt/lib/repair.sml\nml-lpt/lib/ulex-buffer.sml\nml-lpt/lib/wrapped-strm.sml\n)\n\nPROGLR_PARSE_SML\nPROGLR_SCAN_SML\nPROGLR_MAIN_SML\n"),
  ("main.depend.m4", "smlnj-lib/Util/utf8.alc: smlnj-lib/Util/utf8-sig.alc\n\nml-lpt/lib/antlr-lexer-sig.alc: ml-lpt/lib/stream-pos.alc\nml-lpt/lib/ebnf.alc: ml-lpt/lib/stream-pos.alc\nml-lpt/lib/repair.alc: ml-lpt/lib/stream-pos.alc\nml-lpt/lib/ulex-buffer.alc: ml-lpt/lib/stream-pos.alc\nml-lpt/lib/wrapped-strm.alc: ml-lpt/lib/antlr-tokens-sig.alc ml-lpt/lib/antlr-lexer-sig.alc ml-lpt/lib/repair.alc ml-lpt/lib/stream-pos.alc\n\nPROGLR_PARSE_ALC: ml-lpt/lib/stream-pos.alc\nPROGLR_SCAN_ALC: PROGLR_PARSE_ALC ml-lpt/lib/ulex-buffer.alc smlnj-lib/Util/utf8.alc ml-lpt/lib/stream-pos.alc\n\nmain.alc: PROGLR_PARSE_ALC PROGLR_SCAN_ALC ml-lpt/lib/stream-pos.alc\n"),
  ("polybuild.tcl", "#!/bin/sh\n# vim: set filetype=tcl : \\\nexec expect -f \"$0\" ${1+\"$@\"}\n\nset prompt \"\\n> \"\nset errmsg \"Error\"\n\nif {[info exists env(DEBUG)] && $env(DEBUG)} {\n  set debug 1\n} else {\n  set debug 0\n}\n\nspawn poly\nexpect -- $prompt\n\nset errorOccurred 0\n\nif {$debug} {\n  send \"PolyML.Compiler.debug := true;\\r\"\n  expect -- $prompt\n}\n\nforeach source $argv {\n  send \"use \\\"$source\\\";\\r\"\n  expect {\n    $errmsg {\n      set errorOccurred 1\n      break\n    }\n    -- $prompt {}\n  }\n}\n\nif {$debug} {\n  send \"open PolyML.Debug;\\r\"\n  interact\n  exit $errorOccurred\n}\n\nif {!$errorOccurred} {\n  send \"PolyML.export(\\\"a\\\", main);\\r\"\n  expect {\n    $errmsg {\n      set errorOccurred 1\n    }\n    -- $prompt {}\n  }\n}\n\nsend \"\\004\"\nexpect eof\nexit $errorOccurred\n"),
  ("Makefile.poly.m4", "FILES = \\\nsmlnj-lib/Util/utf8-sig.sml \\\nsmlnj-lib/Util/utf8.sml \\\nml-lpt/lib/stream-pos.sml \\\nml-lpt/lib/antlr-lexer-sig.sml \\\nml-lpt/lib/antlr-tokens-sig.sml \\\nml-lpt/lib/ebnf.sml \\\nml-lpt/lib/repair.sml \\\nml-lpt/lib/ulex-buffer.sml \\\nml-lpt/lib/wrapped-strm.sml \\\nPROGLR_PARSE_SML \\\nPROGLR_SCAN_SML \\\nmain.sml\n\nmain: PROGLR_PARSE_SML PROGLR_SCAN_SML main.sml \n\texpect -f polybuild.tcl $(FILES)\n\tpolyc -o main a.o\n\ndebug: PROGLR_PARSE_SML PROGLR_SCAN_SML main.sml \n\tenv DEBUG=1 expect -f polybuild.tcl $(FILES)\n\nPROGLR_SCAN_SML: PROGLR_SCAN_ULEX\n\tml-ulex PROGLR_SCAN_ULEX\n\nclean:\n\trm -f main\n\trm -f *.o\n"),
  ("Makefile.alice.m4", "SRCS = \\\nsmlnj-lib/Util/utf8-sig.sml \\\nsmlnj-lib/Util/utf8.sml \\\nml-lpt/lib/stream-pos.sml \\\nml-lpt/lib/antlr-lexer-sig.sml \\\nml-lpt/lib/antlr-tokens-sig.sml \\\nml-lpt/lib/ebnf.sml \\\nml-lpt/lib/repair.sml \\\nml-lpt/lib/ulex-buffer.sml \\\nml-lpt/lib/wrapped-strm.sml \\\nPROGLR_PARSE_SML \\\nPROGLR_SCAN_SML \\\nmain.sml\n\nOBJS = $(SRCS:.sml=.alc)\n\nall: $(OBJS)\n\n%.alc:\t%.sml \n\talicec --dependency-file main.depend --no-warn-conventions $< -o $@ \n\nclean:\n\trm -f $(OBJS)\n\n"),
    ("", "") ]
  fun get path =
    let fun get' [] = raise Empty
          | get' ((path', datum)::resources) =
              if path = path' then datum
              else get' resources
    in
      get' resources
    end
end